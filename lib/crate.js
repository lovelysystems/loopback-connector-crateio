/*!
 * Module dependencies
 */
var crate = require('node-crate');
var SqlString = require('./SqlString');

var SqlConnector = require('loopback-connector').SqlConnector;

var async = require('async');

/**
 * @module loopback-connector-crate
 *
 * Initialize the Crate connector against the given data source
 *
 * @param {DataSource} dataSource The loopback-datasource-juggler dataSource
 * @param {Function} [callback] The callback function
 */
exports.initialize = function initializeDataSource(dataSource, callback) {
  if (!crate) {
    return;
  }

  var s = dataSource.settings;
  var options = {
    host: s.host || s.hostname || 'localhost',
    port: s.port || 4200
  };

  crate.connect(options.host, options.port);
  dataSource.client = crate;

  dataSource.isRelational = function() {
      return false;
  };

  dataSource.connector = new Crate(dataSource.client, s);
  dataSource.connector.dataSource = dataSource;

  if (callback) {
      process.nextTick(function () {
        callback();
      });
  }
};

exports.Crate = Crate;

/**
 * @constructor
 * Constructor for Crate connector
 * @param {Object} client The node-crate client object
 */
function Crate(client, settings) {
  this.name = 'crate';
  this._models = {};
  this.client = client;
  this.settings = settings;
}

require('util').inherits(Crate, SqlConnector);

Crate.prototype.getDefaultIdType = function() {
  return String;
};

/**
 * Execute the sql statement
 *
 * @param {String} sql The SQL statement
 * @param {Function} [callback] The callback after the SQL statement is executed
 */
Crate.prototype.query = function (sql, callback) {
  var self = this;
  if (!this.dataSource.connected) {
    return this.dataSource.once('connected', function () {
      this.query(sql, callback);
    }.bind(this));
  }
  var client = this.client;
  var time = Date.now();
  var db = this.settings.database;
  var log = this.log;
  if (typeof callback !== 'function') {
      throw new Error('callback should be a function');
  }

  function releaseConnectionAndCallback(connection, err, result) {
    connection.release();
    if (callback) {
        callback(err, result);
    }
  }

  console.log('sql:', sql);
  var res = crate.execute(sql);

  res.success(function(res) {
    callback(null, res.json);
  });
  res.error(function(err) {
    console.log('* query error:', err);
    callback(err, null);
  });

};

Crate.prototype.randomIdGenerator = function() {
    // TODO: make this configurable?
    // http://stackoverflow.com/questions/105034/create-guid-uuid-in-javascript
    function s4() {
        return Math.floor((1 + Math.random()) * 0x10000)
                .toString(16)
                .substring(1);
    }
    return s4() + s4() + '-' + s4() + '-' + s4() + '-' +
        s4() + '-' + s4() + s4() + s4();
};

/**
 * Create the data model in Crate
 *
 * @param {String} model The model name
 * @param {Object} data The model instance data
 * @param {Function} [callback] The callback function
 */
Crate.prototype.create = function (model, data, callback) {
    var keys = [],
        values = [],
        sql = 'INSERT INTO ' + this.tableEscaped(model),
        id = null;
    for (var k in data) {
        if (k === 'id') {
            id = data[k];
            if (!id) {
                continue; // ID is inserted and generated later on.
            }
        }
        keys.push(k);
        values.push(this.typify(model, k, data[k]));
    }
    if (!id) {
        id = this.randomIdGenerator();
        keys.push('id');
        values.push("'" + id + "'");
    }
    sql += ' (' + keys.join() + ') VALUES (' + values.join() + ')';
    var self = this;
    self.query(sql, function (err, info) {
        if (err) {
            callback(err);
            return;
        }
        // Because of eventually consistency of crate inserts/updates we must
        // refresh the table to make sure the object is immediately available
        // for queries.
        // TODO: make this behaviour configurable
        self.query('REFRESH TABLE ' + self.tableEscaped(model), function(err, info) {
            if (err) {
                callback(err);
                return;
            }
            // ID is not generated by the database. As a result, 'info' is empty.
            // We need to provide the generated ID.
            callback(err, id);
        });
    });
};


Crate.prototype.typify = function(model, key, val) {
    var props = this._models[model].properties;
    if (val == void 0) {
        return 'NULL';
    }

    function arrayToCrateSQL(val) {
        var first = true,
            arr = '[';
        for (var i in val) {
            if (!first) {
                arr += ', ';
            }
            arr += ("'" + val[i] + "'");
            first = false;
        }
        arr += ']';
        return arr;
    }

    function objectToCrateSQL(val) {
        var objLiteral = '{';
        var keys = Object.keys(val);
        for (var idx = 0; idx < keys.length; idx++) {
            var k = keys[idx];
            var v = val[k];
            objLiteral += '"' + k + '"=';
            if (Array.isArray(v)) {
                objLiteral += arrayToCrateSQL(v);
            } else {
                if (typeof(v) === 'number') {
                    objLiteral += v;
                } else if (typeof(v) === 'string') {
                    objLiteral += "'" + v + "'";
                }
            }
            if (idx < keys.length - 1) {
                objLiteral += ', ';
            }
        }
        return objLiteral + '}';
    }

    if (props[key]) {
        if (Array.isArray(val)) {
            return arrayToCrateSQL(val);
        }
        switch (props[key].type.name) {
            case 'String':
            case 'Text':
                return "'" + val + "'";
            case 'Boolean':
                return Boolean(val);
            case 'Object':
                return objectToCrateSQL(val);
            case 'Date':
                return val && "'" + val.toISOString() + "'" || 'NULL';
            case 'GeoPoint':
            case 'Point':
                return {
                    lat: val.x,
                    lng: val.y
                };
            default:
                return val;
        }
    }
};


/**
 * Update all instances that match the where clause with the given data
 * @param {String} model The model name
 * @param {Object} data The property/value object representing changes to be made
 * @param {Function} callback The callback function
 */
Crate.prototype.update =
  Crate.prototype.updateAll = function (model, where, data, callback) {
    var whereClause = this.buildWhere(model, where);

    var sql = 'UPDATE ' + this.tableEscaped(model) + ' SET ' +
      this.toFields(model, data) + ' ' + whereClause;

    this.query(sql, function (err, result) {
      if (callback) {
        callback(err, result);
      }
    });
  };

Crate.prototype.toFields = function(model, data) {
  var self = this;
  var fields = [];
  var props = this._models[model].properties;
  var idName = this.idName(model);
  var idProp = this._models[model].properties[idName];
  Object.keys(data).forEach(function (key) {
    if (props[key] && props[key] !== idProp) {
      var value = this.toDatabase(props[key], data[key], true);
      if (undefined === value) {
        return;
      }
      fields.push(self.columnEscaped(model, key) + " = " + value);
    }
  }.bind(this));
  return fields.join(',');
};

function dateToCrate(val) {
  return val.getUTCFullYear() + '-' +
    fillZeros(val.getUTCMonth() + 1) + '-' +
    fillZeros(val.getUTCDate()) + ' ' +
    fillZeros(val.getUTCHours()) + ':' +
    fillZeros(val.getUTCMinutes()) + ':' +
    fillZeros(val.getUTCSeconds());

  function fillZeros(v) {
    return v < 10 ? '0' + v : v;
  }
}

/*!
 * Convert property name/value to a DB column
 * @param prop
 * @param val
 * @returns {*}
 */
Crate.prototype.toDatabase = function(prop, val, forCreate) {
  if (val === null || val === undefined) {
    return 'NULL';
  }
  if (!forCreate && val.constructor.name === 'Object') {
    var operator = Object.keys(val)[0];
    val = val[operator];
    if (operator === 'inq' || operator === 'nin') {
      if (Array.isArray(val)) { //if value is array
        for (var i = 0; i < val.length; i++) {
          val[i] = this.toDatabase(prop, val[i]);
        }
        return val.join(',');
      } else {
        return this.toDatabase(prop, val);
      }
    }
    return this.toDatabase(prop, val);
  }
  if (!prop) {
    return SqlString.escape(val);
  }
  if (prop.type === String) {
    return SqlString.escape(val);
  }
  if (prop.type === Number) {
    if (isNaN(val)) {
        return 'NULL';
    }
    return SqlString.escape(val);
  }
  if (prop.type === Date) {
    if (!val.toUTCString) {
      // not a Date object, try to create one
      val = new Date(val);
    }
    return SqlString.escape(val);
  }
  if (prop.type === Boolean) {
    return SqlString.escape(val);
  }
  if (prop.type && prop.type.name === 'GeoPoint') {
    return val ? 'Point(' + val.lat + ',' + val.lng + ')' : 'NULL';
  }
  if (prop.type === Object) {
    return val;
  }
  if (typeof prop.type === 'function') {
    if (prop.type.modelName) {
      // For embedded models
      return JSON.stringify(val);
    }
    return prop.type(val);
  }
  return val.toString();
};

/*!
 * Convert the data from database
 * @param model
 * @param data
 * @returns {*}
 */
Crate.prototype.fromDatabase = function (model, data) {
  if (!data) {
    return null;
  }
  var props = this._models[model].properties;
  var json = {};
  for (var p in props) {
    var key = this.column(model, p);
    var val = data[key];
    if (val === undefined) {
      continue;
    }
    if (val === null) {
      json[p] = null;
      continue;
    }
    if (props[p]) {
      switch (props[p].type.name) {
        case 'Date':
          val = new Date(val.toString().replace(/GMT.*$/, 'GMT'));
          break;
        case 'Boolean':
          val = Boolean(val);
          break;
        case 'GeoPoint':
        case 'Point':
          val = {
            lat: val.x,
            lng: val.y
          };
          break;
      }
    }
    json[p] = val;
  }
  return json;
};

Crate.prototype.escapeName = function (name) {
    return name;
};

Crate.prototype.getColumns = function (model, props) {
  var cols = this._models[model].properties;
  if (!cols) {
    return '*';
  }
  var self = this;
  var keys = Object.keys(cols);
  if (Array.isArray(props) && props.length > 0) {
    // No empty array, including all the fields
    keys = props;
  } else if ('object' === typeof props && Object.keys(props).length > 0) {
    // { field1: boolean, field2: boolean ... }
    var included = [];
    var excluded = [];
    keys.forEach(function (k) {
      if (props[k]) {
        included.push(k);
      } else if ((k in props) && !props[k]) {
        excluded.push(k);
      }
    });
    if (included.length > 0) {
      keys = included;
    } else if (excluded.length > 0) {
      excluded.forEach(function (e) {
        var index = keys.indexOf(e);
        keys.splice(index, 1);
      });
    }
  }
  var names = keys.map(function (c) {
    return self.columnEscaped(model, c);
  });
  return names.join(', ');
};

Crate.prototype.buildWhere = function (model, conds) {
  var where = this._buildWhere(model, conds);
  return where? 'WHERE ' + where : '';
};

Crate.prototype._buildWhere = function (model, conds) {
  if (conds === null || conds === undefined || (typeof conds !== 'object')) {
    return '';
  }
  var self = this;
  var props = self._models[model].properties;

  var cs = [];
  Object.keys(conds).forEach(function (key) {
    if (key === 'and' || key === 'or') {
      var clauses = conds[key];
      if (Array.isArray(clauses)) {
        clauses = clauses.map(function (c) {
          return '(' + self._buildWhere(model, c) + ')';
        });
        return cs.push(clauses.join(' ' + key.toUpperCase() + ' '));
      }
      // The value is not an array, fall back to regular fields
    }
    var keyEscaped = self.columnEscaped(model, key);
    var v = conds[key];
    if (v.constructor.name === 'Object') {
        var operator = Object.keys(v)[0];
        if (operator === 'between') {
            // crate has no between operator, map it to:
            // (property >= value) AND (property <= value)
            var range = v[operator];
            var l = {};
            var r = {};
            l[key] = {gte: range[0]};
            r[key] = {lte: range[1]};
            return cs.push(self._buildWhere(model, {and: [l, r]}));
        }
    }
    var val = self.toDatabase(props[key], conds[key]);
    if (conds[key] === null || conds[key] === undefined) {
      cs.push(keyEscaped + ' IS NULL');
    } else if (conds[key] && conds[key].constructor.name === 'Object') {
      var condType = Object.keys(conds[key])[0];
      var sqlCond = keyEscaped;
      if ((condType === 'inq' || condType === 'nin') && val.length === 0) {
        cs.push(condType === 'inq' ? 0 : 1);
        return true;
      }
      switch (condType) {
        case 'gt':
          sqlCond += ' > ';
          break;
        case 'gte':
          sqlCond += ' >= ';
          break;
        case 'lt':
          sqlCond += ' < ';
          break;
        case 'lte':
          sqlCond += ' <= ';
          break;
        case 'inq':
          sqlCond += ' IN ';
          break;
        case 'nin':
          sqlCond += ' NOT IN ';
          break;
        case 'neq':
          sqlCond += ' != ';
          break;
        case 'like':
          sqlCond += ' LIKE ';
          break;
        case 'nlike':
          sqlCond += ' NOT LIKE ';
          break;
      }
      if (condType === 'like' || condType === 'nlike') {
        sqlCond += val;
      } else if (condType === 'inq' || condType === 'nin') {
        sqlCond += '(' + val + ')';
      } else {
        sqlCond += val;
      }
      cs.push(sqlCond);
    } else {
      cs.push(keyEscaped + ' = ' + val);
    }
  });
  if (cs.length === 0) {
    return '';
  }
  return cs.join(' AND ');
};

function buildOrderBy(self, model, order) {
  if (typeof order === 'string') {
    order = [order];
  }
  return 'ORDER BY ' + order.map(function (o) {
    var t = o.split(/[\s,]+/);
    if (t.length === 1) {
      return self.columnEscaped(model, o);
    }
    return self.columnEscaped(model, t[0]) + ' ' + t[1];
  }).join(', ');
}

function buildLimit(limit, offset) {
  if (isNaN(limit)) {
    limit = 0;
  }
  if (isNaN(offset)) {
    offset = 0;
  }
  var ret = '';
  if (!!limit) {
    ret += 'LIMIT ' + limit;
  }
  if (!!offset) {
    ret += ' OFFSET ' + offset;
  }
  return ret;
}

/**
 * Find matching model instances by the filter
 *
 * @param {String} model The model name
 * @param {Object} filter The filter
 * @param {Function} [callback] The callback function
 */
Crate.prototype.all = function all(model, filter, callback) {
  var self = this;
  // Order by id if no order is specified
  filter = filter || {};
  if (!filter.order) {
    var idNames = this.idNames(model);
    if (idNames && idNames.length) {
      filter.order = idNames;
    }
  }

  var sql = 'SELECT ' +
            this.getColumns(model, filter.fields) +
            ' FROM ' +
            this.tableEscaped(model);

  if (filter) {
    if (filter.where) {
      sql += ' ' + self.buildWhere(model, filter.where);
    }
    if (filter.order) {
      sql += ' ' + buildOrderBy(self, model, filter.order);
    }
    if (filter.limit) {
      sql += ' ' + buildLimit(filter.limit, filter.skip || filter.offset || 0);
    }
  }

  this.query(sql, function (err, data) {
    if (err) {
      return callback(err, []);
    }
    var objs = data.map(function (obj) {
      return self.fromDatabase(model, obj);
    });
    if (filter && filter.include) {
      this._models[model].model.include(objs, filter.include, callback);
    } else {
      callback(null, objs);
    }
  }.bind(this));

  return sql;

};

Crate.prototype.count = function count(model, callback, where) {
  this.query('SELECT count(*) as cnt FROM ' +
      this.tableEscaped(model) + ' ' + this.buildWhere(model, where),
    function (err, res) {
      if (err) {
        return callback(err);
      }
      var c = (res && res[0] && res[0].cnt) || 0;
      callback(err, c);
    });
};


/**
 * Drop the table for the given model from the database
 * @param {String} model The model name
 * @param {Function} [cb] The callback function
 */
SqlConnector.prototype.dropTable = function (model, cb) {
  this.command('DROP TABLE ' + this.tableEscaped(model), cb);
};


/**
 * Delete instances for the given model
 *
 * @param {String} model The model name
 * @param {Object} [where] The filter for where
 * @param {Function} [callback] The callback function
 *
 */
Crate.prototype.destroyAll = function destroyAll(model, where, callback) {
  if (!callback && 'function' === typeof where) {
    callback = where;
    where = undefined;
  }
  this.query('DELETE FROM '
      + this.tableEscaped(model) + ' ' + this.buildWhere(model, where || {}),
    function (err, data) {
      callback && callback(err, data);
    }.bind(this));
};

/**
 * Perform autoupdate for the given models
 * @param {String[]} [models] A model name or an array of model names. If not present, apply to all models
 * @param {Function} [cb] The callback function
 */
Crate.prototype.autoupdate = function (models, cb) {
  var self = this;

  if ((!cb) && ('function' === typeof models)) {
    cb = models;
    models = undefined;
  }
  // First argument is a model name
  if ('string' === typeof models) {
    models = [models];
  }

  models = models || Object.keys(this._models);

  async.each(models, function(model, done) {
    if (!(model in self._models)) {
      return process.nextTick(function() {
        done(new Error('Model not found: ' + model));
      });
    }
    var table = self.tableEscaped(model);
    self.createTable(model, done);
  }, cb);

};

/*!
 * Create table
 * @param model
 * @param cb
 */
Crate.prototype.createTable = function (model, cb) {
  var metadata = this._models[model].settings[this.name];
  var sql = 'CREATE TABLE ' +
            this.tableEscaped(model) +
            ' (\n  ' +
            this.propertiesSQL(model, true, true) +
            '\n)';
  this.query(sql, cb);
};

/**
 * Check if the models exist
 * @param {String[]} [models] A model name or an array of model names. If not present, apply to all models
 * @param {Function} [cb] The callback function
 */
Crate.prototype.isActual = function(models, cb) {
  var self = this;
  var ok = false;

  if ((!cb) && ('function' === typeof models)) {
    cb = models;
    models = undefined;
  }
  // First argument is a model name
  if ('string' === typeof models) {
    models = [models];
  }

  models = models || Object.keys(this._models);

  async.each(models, function(model, done) {
    var table = self.tableEscaped(model);
    self.query('SHOW FIELDS FROM ' + table, function(err, fields) {
      self.query('SHOW INDEXES FROM ' + table, function(err, indexes) {
        self.alterTable(model, fields, indexes, function(err, needAlter) {
          if (err) {
            return done(err);
          } else {
            ok = ok || needAlter;
            done(err);
          }
        }, true);
      });
    });
  }, function(err) {
    if (err) {
      return err;
    }
    cb(null, !ok);
  });
};

Crate.prototype.alterTable = function (model, actualFields, actualIndexes, done, checkOnly) {
  var self = this;
  var m = this._models[model];
  var propNames = Object.keys(m.properties).filter(function (name) {
    return !!m.properties[name];
  });
  var indexNames = m.settings.indexes ? Object.keys(m.settings.indexes).filter(function (name) {
    return !!m.settings.indexes[name];
  }) : [];
  var sql = [];

  // change/add new fields
  propNames.forEach(function (propName) {
    if (m.properties[propName] && self.id(model, propName)) return;
    var found;
    if (actualFields) {
      actualFields.forEach(function (f) {
        if (f.Field === propName) {
          found = f;
        }
      });
    }

    if (!found) {
        sql.push('ADD COLUMN ' +
                 self.client.escapeId(propName) +
                 ' ' +
                 self.propertySettingsSQL(model, propName));
    }
  });

  if (sql.length) {
    var query = 'ALTER TABLE ' + self.tableEscaped(model) + ' ' + sql.join(',\n');
    if (checkOnly) {
      done(null, true, {statements: sql, query: query});
    } else {
      this.query(query, done);
    }
  } else {
    done();
  }
};

/* Create properties SQL
 *
 * This will create a string containing the properties to be able to create a
 * new table.
 */
Crate.prototype.propertiesSQL = function (model, withPks, withGenerated) {
  var self = this;

  var pks = [];
  if (withPks) {
      pks = this.idNames(model).map(function (i) {
        return self.columnEscaped(model, i);
      });
  }

  var sql = [];
  if (pks.length === 1) {
    var idName = this.idName(model);
    var idProp = this._models[model].properties[idName];
    if(idProp.generated) {
      sql.push(self.columnEscaped(model, idName) + ' STRING PRIMARY KEY');
    } else {
      idProp.nullable = false;
      sql.push(self.columnEscaped(model, idName) + ' ' + self.propertySettingsSQL(model, idName) + ' PRIMARY KEY');
    }
  }
  Object.keys(this._models[model].properties).forEach(function (prop) {
    if ((self.id(model, prop) && pks.length === 1) ||
        (!withGenerated && self._models[model].properties[prop].generated)
       ) {
      return;
    }
    var colName = self.columnEscaped(model, prop);
    sql.push(colName + ' ' + self.propertySettingsSQL(model, prop));
  });
  if (pks.length > 1) {
    sql.push('PRIMARY KEY(' + pks.join(',') + ')');
  }
  return sql.join(',\n  ');
};

Crate.prototype.propertySettingsSQL = function (model, prop) {
  var index = this._models[model].properties[prop].index;
  var p = this._models[model].properties[prop];
  var line = this.columnDataType(model, prop);
  if (index === false) {
    line += " INDEX OFF";
  }
  return line;
};

Crate.prototype.columnDataType = function (model, property) {
  var columnMetadata = this.columnMetadata(model, property);
  var colType = columnMetadata && columnMetadata.dataType;
  if (colType) {
    colType = colType.toUpperCase();
  }
  var prop = this._models[model].properties[property];
  if (!prop) {
    return null;
  }
  return this.datatype(prop);
};

Crate.prototype.datatype = function(p) {
    var dt = '';
    var typeName = '',
        isArray = Array.isArray(p.type);
    if (isArray) {
        typeName = 'Array';
    } else {
        typeName = p.type.name;
    }

    switch (typeName) {
        case 'Text':
        case 'String':
            dt = columnType(p, 'STRING');
            break;
        case 'Number':
            dt = columnType(p, 'INT');
            break;
        case 'Array':
            dt = 'ARRAY(' + p.type[0].name + ')';
            break;
        case 'Date':
            dt = columnType(p, 'TIMESTAMP'); // Currently doesn't need options.
            break;
        case 'Boolean':
            dt = 'BOOLEAN';
            break;
        case 'Point':
        case 'GeoPoint':
            dt = 'GEO_POINT';
            break;
        default:
            // JSON, Object, Any
            dt = columnType(p, 'OBJECT');
            if (p.policy) {
                dt += '(' + p.policy +')';
            }
            if (p.schema) {
                var d = this.propertiesSQL(p.schema, false, false);
                dt += ' as (\n  ' + d + '\n  )';
            }
    }
    return dt;
};

function columnType(p, defaultType) {
    var dt = defaultType;
    if (p.dataType) {
        dt = String(p.dataType);
    }
    return dt;
}

/**
 * Disconnect from Crate
 */
Crate.prototype.disconnect = function () {
  if (this.client) {
    this.client.end();
  }
};

Crate.prototype.ping = function(cb) {
  this.query('SELECT 1 AS result', cb);
};

require('./discovery')(Crate);

